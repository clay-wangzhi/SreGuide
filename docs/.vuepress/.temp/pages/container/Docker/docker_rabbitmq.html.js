export const data = JSON.parse("{\"key\":\"v-b7534df8\",\"path\":\"/container/Docker/docker_rabbitmq.html\",\"title\":\"docker 安装rabbitmq集群\",\"lang\":\"zh-CN\",\"frontmatter\":{\"category\":\"常见服务的搭建\",\"tag\":[\"docker\",\"rabbitmq\"],\"description\":\"docker 安装rabbitmq集群 RabbitMQ 高可用集群架构 将两个 RabbitMQ 磁盘节点和一个 RabbitMQ 内存节点组成一个内建集群，之所以要用两个磁盘节点是防止，唯一的磁盘节点挂掉后，不能重建队列，交换器。用 HAProxy 作为 RabbitMQ 集群的负载均衡。为了防止 HAProxy 单点故障，用 Keepalived 将两个 HAProxy 节点做成一主一备。应用使用 VIP（虚拟IP） 访问 HAProxy 服务时，默认连接主机（Master）的 HAProxy，当主机（Master）上的 HAProxy 故障时，VIP 会漂移到备机（Backup）上，就会连接备机（Backup）上的 HAProxy 服务。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://clay-wangzhi.com/container/Docker/docker_rabbitmq.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"SRE运维进阶之路\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"docker 安装rabbitmq集群\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"docker 安装rabbitmq集群 RabbitMQ 高可用集群架构 将两个 RabbitMQ 磁盘节点和一个 RabbitMQ 内存节点组成一个内建集群，之所以要用两个磁盘节点是防止，唯一的磁盘节点挂掉后，不能重建队列，交换器。用 HAProxy 作为 RabbitMQ 集群的负载均衡。为了防止 HAProxy 单点故障，用 Keepalived 将两个 HAProxy 节点做成一主一备。应用使用 VIP（虚拟IP） 访问 HAProxy 服务时，默认连接主机（Master）的 HAProxy，当主机（Master）上的 HAProxy 故障时，VIP 会漂移到备机（Backup）上，就会连接备机（Backup）上的 HAProxy 服务。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Clay\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"docker\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"rabbitmq\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"docker 安装rabbitmq集群\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Clay\\\",\\\"url\\\":\\\"https://clay-wangzhi.com\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"RabbitMQ 高可用集群架构\",\"slug\":\"rabbitmq-高可用集群架构\",\"link\":\"#rabbitmq-高可用集群架构\",\"children\":[]},{\"level\":2,\"title\":\"服务器规划\",\"slug\":\"服务器规划\",\"link\":\"#服务器规划\",\"children\":[]},{\"level\":2,\"title\":\"准备工作\",\"slug\":\"准备工作\",\"link\":\"#准备工作\",\"children\":[{\"level\":3,\"title\":\"安装Docker和Docker Compose\",\"slug\":\"安装docker和docker-compose\",\"link\":\"#安装docker和docker-compose\",\"children\":[]},{\"level\":3,\"title\":\"下载rabbitmq和haproxy镜像\",\"slug\":\"下载rabbitmq和haproxy镜像\",\"link\":\"#下载rabbitmq和haproxy镜像\",\"children\":[]}]},{\"level\":2,\"title\":\"部署rabbitmq集群\",\"slug\":\"部署rabbitmq集群\",\"link\":\"#部署rabbitmq集群\",\"children\":[{\"level\":3,\"title\":\"部署192.168.125.26节点\",\"slug\":\"部署192-168-125-26节点\",\"link\":\"#部署192-168-125-26节点\",\"children\":[]},{\"level\":3,\"title\":\"部署192.168.125.190节点\",\"slug\":\"部署192-168-125-190节点\",\"link\":\"#部署192-168-125-190节点\",\"children\":[]},{\"level\":3,\"title\":\"部署192.168.125.176节点\",\"slug\":\"部署192-168-125-176节点\",\"link\":\"#部署192-168-125-176节点\",\"children\":[]}]},{\"level\":2,\"title\":\"HaProxy 负载均衡\",\"slug\":\"haproxy-负载均衡\",\"link\":\"#haproxy-负载均衡\",\"children\":[]},{\"level\":2,\"title\":\"使用 Keepalived 给 HAProxy 做主备\",\"slug\":\"使用-keepalived-给-haproxy-做主备\",\"link\":\"#使用-keepalived-给-haproxy-做主备\",\"children\":[]}],\"readingTime\":{\"minutes\":6.25,\"words\":1876},\"filePathRelative\":\"container/Docker/docker_rabbitmq.md\",\"excerpt\":\"<h1> docker 安装rabbitmq集群</h1>\\n<h2> RabbitMQ 高可用集群架构</h2>\\n<p><img src=\\\"https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/rabbitmq_ha.png\\\" alt=\\\"img\\\"></p>\\n<p>将两个 RabbitMQ 磁盘节点和一个 RabbitMQ 内存节点组成一个内建集群，之所以要用两个磁盘节点是防止，唯一的磁盘节点挂掉后，不能重建队列，交换器。用 HAProxy 作为 RabbitMQ 集群的负载均衡。为了防止 HAProxy 单点故障，用 Keepalived 将两个 HAProxy 节点做成一主一备。应用使用 VIP（虚拟IP） 访问 HAProxy 服务时，默认连接主机（Master）的 HAProxy，当主机（Master）上的 HAProxy 故障时，VIP 会漂移到备机（Backup）上，就会连接备机（Backup）上的 HAProxy 服务。</p>\",\"copyright\":{\"author\":\"Clay\"},\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
