import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e as n}from"./app-4e885309.js";const i={},l=n(`<h1 id="_5-4-使用lookup生成变量" tabindex="-1"><a class="header-anchor" href="#_5-4-使用lookup生成变量" aria-hidden="true">#</a> 5.4 使用lookup生成变量</h1><h1 id="简单说明" tabindex="-1"><a class="header-anchor" href="#简单说明" aria-hidden="true">#</a> 简单说明</h1><p>在通常情况下，所有的配置信息都会被作为ansible的变量保存了，而且可以保存在ansible允许定义变量的各种地方，诸如vars区段，<code>vars_files</code>加载的文件中，以及host_vars和group_vars目录中。</p><p>但在有些时候，我们希望从诸如文本文件或者.csv文件中收集数据作为ansible的变量，或者直接获取某些命令的输出作为ansible的变量，甚至从redis或者etcd这样的键值存储中取得相应的值作为ansible的变量。这个时候，我们就需要通过ansible的lookup插件来从这些数据源中读取配置数据，传递给ansbile变量，并在playbook或者模板中使用这些数据。</p><p>lookup()是Ansible的一个插件，可用于从外部读取数据，这里的&quot;外部&quot;含义非常广泛，比如：</p><p>(1).从磁盘文件读取(file插件)</p><p>(2).从redis中读取(redis插件)</p><p>(3).从etcd中读取(etcd插件)</p><p>(4).从命令执行结果读取(pipe插件)</p><p>(5).从Ansible变量中读取(vars插件)</p><p>(6).从Ansible列表中读取(list插件)</p><p>(7).从Ansible字典中读取(dict插件)</p><p>(8)....</p><p>具体可以从哪些&quot;外部&quot;读取以及如何读取，取决于Ansible是否提供了相关的读取插件。官方手册：https://docs.ansible.com/ansible/latest/plugins/lookup.html#plugin-list 中列出了所有支持的插件</p><p><strong>lookup()语法</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lookup(&#39;&lt;plugin_name&gt;&#39;, &#39;plugin_argument&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_1-file-fileglob" tabindex="-1"><a class="header-anchor" href="#_1-file-fileglob" aria-hidden="true">#</a> 1. file/fileglob</h1><p>使用file lookup可以从文本文件中获取数据，并在这些数据传递给ansible变量，在task或者jinja2模板中进行引用。下面是一个从文本文件中获取ssh公钥并复制到远程主机的示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: copy authorized_host file
  template: 
    src: authorized_keys.j2 
    dest: /home/deploy/.ssh/authrized_keys 
    owner: deploy
    group: deploy
    mode: 0600
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>authorized_keys.j2模板文件示例如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">{</span><span class="token punctuation">{</span> lookup(&#39;file&#39;<span class="token punctuation">,</span> &#39;/users/breeze/.ssh/id_rsa.pub&#39;)<span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>和file类似，支持通配符的fileglob插件，它使用通配符来通配Ansible本地端的文件名</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>---
- name: play1
  hosts: new
  gather_facts: false
  tasks:
    - name: task1
  debug:
    msg: &quot;filenames: {{lookup(&#39;fileglob&#39;,&#39;/etc/*.conf&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需注意的是，fileglob查询的是Ansible端文件，且只能通配文件而不能通配目录，且不会递归通配。如果想要查询目标主机上的文件，可以使用find模块。</p><blockquote><p>如果lookup()查询出来的结果包含多项，则默认以逗号分隔各项的字符串方式返回，如果想要以列表方式返回，则传递一个lookup的参数wantlist=True。例如，fileglob通配出来的文件如果有多个，加上wantlist=True：</p></blockquote><p>在Ansible 2.5中添加了一个新的功能query()或q()，后者是前者的等价缩写形式。query()在写法和功能上和lookup一致，其实它会自动调用lookup插件，并且总是以列表方式返回，而不需要手动加上wantlist=True参数。例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: task1
  debug:
  msg: &quot;{{q(&#39;fileglob&#39;,&#39;/etc/*.conf&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_2-pipe" tabindex="-1"><a class="header-anchor" href="#_2-pipe" aria-hidden="true">#</a> 2. pipe</h1><p>使用pipe lookup可以直接调用外部命令，并将命令执行的结果打印到标准输出，作为ansible变量。下面的例子通过pipe调用date指令拿到一个以时间数字组成的字串</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: Flamingo | Get release version
  set_fact:
    flamingo_release_version: &quot;{{ lookup(&#39;pipe&#39;, &#39;date +%Y%m%d%H%M%SZ&#39;) }}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_3-env" tabindex="-1"><a class="header-anchor" href="#_3-env" aria-hidden="true">#</a> 3. env</h1><p>env lookup实际就是获取在控制主机上的某个环境变量的值。下面是一个读取控制机上<code>$JAVA_HOME</code>变量值的示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: get JAVA_HOME
  debug: msg=&quot;{{ lookup(&#39;env&#39;, &#39;JAVA_HOME&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_4-template" tabindex="-1"><a class="header-anchor" href="#_4-template" aria-hidden="true">#</a> 4. template</h1><p>template lookup可以指定一个jinja2模板，然后返回这个模板中的变量被替换以后的结果。</p><p>假设我们有一个message.j2模板，内容如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>This host runs {{ ansible_distribution }}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>定义一个如下的task：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: print message from template
  debug: msg=&quot;{{ lookup(&#39;template&#39;, &#39;message.j2&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的msg的结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>This host runs CentOS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_5-csvfile" tabindex="-1"><a class="header-anchor" href="#_5-csvfile" aria-hidden="true">#</a> 5. csvfile</h1><p>csvfile可以从.csv文件中读取一个条目。假设我们有如下示例的名为users.csv的文件：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>username,email
lorin,lorin@test.com
john,john@example.com
sue,sue@exmaple.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个使用csvfile lookkup提取sue的电子邮件地址的task示例：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> get sue&#39;s email
  <span class="token key atrule">debug</span><span class="token punctuation">:</span> msg=&quot;<span class="token punctuation">{</span><span class="token punctuation">{</span> lookup(&#39;csvfile&#39;<span class="token punctuation">,</span>&#39;sue file=users.csv delimiter=<span class="token punctuation">,</span> col=1&#39;)<span class="token punctuation">}</span><span class="token punctuation">}</span>&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，一共向插件传递了四个参数：sue, file=users.csv, delimiter=,以及col=1。说明如下：</p><ul><li>第一个参数指定一个名字，该名字必须出现在其所在行的第0列，需要说明的是，如果指定的第一个参数名字在文件中出现多次，则匹配第一次出现的结果</li><li>第二个参数指定csv文件的文件名</li><li>第三个参数指定csv文件的中条目的分隔符，</li><li>第四个参数指定要取得哪一列的值，这一列正是第一个参数所在行的那一列的值</li></ul><p>如果我们想要查找的用户存储在名为username的变量中，则可以使用&quot;+&quot;符号来连接username字串和其他的参数字串，来构建完整的参数字符串：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lookup(&#39;csvfile&#39;, username+&#39;file=users.csv&#39; delimiter=, col=1)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_6-redis-kv" tabindex="-1"><a class="header-anchor" href="#_6-redis-kv" aria-hidden="true">#</a> 6. redis_kv</h1><p><code>redis_kv lookup</code>可以直接从redis存储中来获取一个key的value，key必须是一个字符串，如同Redis GET指令一样。需要注意的是，要使用<code>redis_kv lookup</code>，需要在主控端安装python的redis客户端，在centos上，软件包为python-redis。</p><p>下面是一个在playbook中调用redis lookup的task，从本地的redis中取中一个key为weather的值：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: lookup value in redis
  debug: msg=&quot;{{ lookup(&#39;redis_kv&#39;, &#39;redis://localhost:6379,weather&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中URL部分如果不指定，该模块会默认连接到<code>redis://localhost:6379</code>，所以实际上在上面的实例中，调用可以直接写成如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{{ lookup(&#39;redis_kv&#39;, &#39;weather&#39;)}}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_7-etcd" tabindex="-1"><a class="header-anchor" href="#_7-etcd" aria-hidden="true">#</a> 7. etcd</h1><p>etcd是一个分布式的key-value存储，通常被用于保存配置信息或者被用于实现服务发现。可以使用etcd lookup来从etcd中获取指定key的value。</p><p>我们通过如下方法往一个etcd中写入一个key：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>curl -L http://127.0.0.1:4001/v2/keys/weather -XPUT -d value=sunny
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>定义一个调用etcd插件的task：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: look up value in etcd
  debug: msg=&quot;{{ lookup(&#39;etcd&#39;,&#39;weather&#39;)}}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，etcd lookup会在http://127.0.0.1:4001上查找etcd服务器。但我们在执行playbook之前可以通过设置<code>ANSIBLE_ETCD_URL</code>环境变量来修改这个设置。</p><h1 id="_8-password" tabindex="-1"><a class="header-anchor" href="#_8-password" aria-hidden="true">#</a> 8. password</h1><p>password lookup会随机生成一个密码，并将这个密码写入到参数指定的文件中。如下示例，创建一个名为bob的mysql用户，并随机生成该用户的密码，并将密码写入到主控端的bob-password.txt中：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: create deploy mysql user
  mysql_user: name=bob password={{ lookup(&#39;password&#39;, &#39;bob-password,txt&#39;)}} priv=*.*:ALL state=present
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_9-dnstxt" tabindex="-1"><a class="header-anchor" href="#_9-dnstxt" aria-hidden="true">#</a> 9. dnstxt</h1><p>dnstxt lookup用于获取指定域名的TXT记录。需要在主控端安装python-dns。</p><p>使用方法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- name: lookup TXT record
  debug: msg=&quot;{{ lookup(&#39;dnstxt&#39;, &quot;aliyun.com&quot;) }}&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果某一个主机有多个相关联的TXT记录，那么模块会把他们连在一起，并且每次调用时的连接顺序可能不同</p><blockquote><p>参考链接：</p><p>https://www.cnblogs.com/breezey/p/9275799.html</p><p>https://blog.51cto.com/cloumn/blog/1544</p></blockquote>`,72),d=[l];function t(o,r){return a(),s("div",null,d)}const p=e(i,[["render",t],["__file","lookup.html.vue"]]);export{p as default};
