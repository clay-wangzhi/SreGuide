import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as r,c,b as e,d as a,a as p,e as d}from"./app-e46907be.js";const t={},i=e("h1",{id:"如何在docker容器中运行docker-3种方法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#如何在docker容器中运行docker-3种方法","aria-hidden":"true"},"#"),a(" 如何在Docker容器中运行Docker [3种方法]")],-1),l={href:"https://cloud.tencent.com/developer/article/1697053",target:"_blank",rel:"noopener noreferrer"},k=d(`<p>在本博客中，我将向您介绍在docker中运行docker所需的三种不同方法。</p><h2 id="docker-in-docker的用处" tabindex="-1"><a class="header-anchor" href="#docker-in-docker的用处" aria-hidden="true">#</a> <strong>Docker In Docker的用处</strong></h2><ol><li>dockerIndocker的一个潜在用处是CI管道，在代码成功构建后，您需要在其中构建docker镜像并将其推送到容器镜像仓库。</li><li>使用VM构建Docker映像非常简单。但是，当您计划将基于 Jenkins docker的动态代理用于CI/CD管道时，docker In docker是必备功能。</li><li>沙盒环境。</li><li>出于实验目的，在您的本地开发工作站上。</li></ol><h2 id="在docker容器中运行docker" tabindex="-1"><a class="header-anchor" href="#在docker容器中运行docker" aria-hidden="true">#</a> <strong>在Docker容器中运行Docker</strong></h2><p>在Docker中实现Docker的三种方法</p><ol><li>通过挂载docker.sock（DooD方法）运行docker</li><li>dind 方法</li><li>使用Nestybox sysbox Docker运行时</li></ol><p>让我们详细了解每个选项。确保在主机中安装了docker来尝试此设置。</p><h3 id="方法1-使用-var-run-docker-sock-的docker中运行docker" tabindex="-1"><a class="header-anchor" href="#方法1-使用-var-run-docker-sock-的docker中运行docker" aria-hidden="true">#</a> <strong>方法1：使用[/var/run/docker.sock]的Docker中运行Docker</strong></h3><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2rkoovauym.png" alt="2rkoovauym"></p><h4 id="什么是-var-run-docker-sock" tabindex="-1"><a class="header-anchor" href="#什么是-var-run-docker-sock" aria-hidden="true">#</a> <strong>什么是/var/run/docker.sock？</strong></h4><p><code>/var/run/docker.sock</code>是默认的Unix套接字。套接字用于在同一主机上的进程之间进行通信。Docker守护程序默认情况下侦听docker.sock。如果您在运行Docker守护程序的主机上，则可以使用/ <code>var/run/docker.sock</code>管理容器。</p><p>例如，如果您运行以下命令，它将返回docker engine的版本。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>curl <span class="token operator">--</span>unix<span class="token operator">-</span>socket <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>version
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在您已经了解了什么是docker.sock，让我们看看如何使用在docker中运行docker。</p><p>要在docker内部运行docker，要做的只是在默认Unix套接字<code>docker.sock</code>作为卷的情况下运行docker 。</p><p>例如，</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker run <span class="token operator">-</span>v <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock<span class="token operator">:</span><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock \\
           <span class="token operator">-</span>ti docker<span class="token operator">-</span>image
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>**请注意：**如果您的容器可以访问docker.sock，则意味着它具有对docker守护程序的更多特权。因此，在实际项目中使用时，请了解并使用安全隐患。</p></blockquote><p>现在，从容器中，您应该能够执行docker命令来构建镜像并将其推送到镜像仓库。在这里，实际的docker操作发生在运行docker容器的VM主机上，而不是在容器内部进行。意思是，即使您正在容器中执行docker命令，也指示Docker客户端通过以下<code>docker.sock</code>方式连接到VM主机docker-engine。</p><p>要测试他的设置，请使用来自docker hub 的官方docker映像。它具有docker二进制文件。</p><p>请按照以下步骤测试设置。</p><p>第1步：以交互方式启动Docker容器，并挂载<code>docker.sock</code>卷。我们将使用官方的docker镜像。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker run <span class="token operator">-</span>v <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock<span class="token operator">:</span><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock <span class="token operator">-</span>ti docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>步骤2：进入容器后，执行以下docker命令。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker pull ubuntu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>步骤3：列出Docker映像时，您应该看到ubuntu映像以及在主机VM中其他Docker映像。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker images
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>步骤4：现在在测试目录中创建一个Dockerfile。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>mkdir test <span class="token operator">&amp;&amp;</span> cd test
vi Dockerfile
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制以下Dockerfile内容以从容器内部测试映像构建。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token constant">FROM</span> <span class="token literal-property property">ubuntu</span><span class="token operator">:</span><span class="token number">18.04</span>

<span class="token constant">LABEL</span> maintainer<span class="token operator">=</span><span class="token string">&quot;Bibin Wilson &lt;bibinwilsonn@gmail.com&gt;&quot;</span>

<span class="token constant">RUN</span> apt<span class="token operator">-</span><span class="token keyword">get</span> update <span class="token operator">&amp;&amp;</span> \\
    apt<span class="token operator">-</span>get <span class="token operator">-</span>qy full<span class="token operator">-</span>upgrade <span class="token operator">&amp;&amp;</span> \\
    apt<span class="token operator">-</span><span class="token keyword">get</span> install <span class="token operator">-</span>qy curl <span class="token operator">&amp;&amp;</span> \\
    apt<span class="token operator">-</span><span class="token keyword">get</span> install <span class="token operator">-</span>qy curl <span class="token operator">&amp;&amp;</span> \\
    curl <span class="token operator">-</span>sSL https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>get<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com<span class="token operator">/</span> <span class="token operator">|</span> sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译Dockerfile</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker build <span class="token operator">-</span>t test<span class="token operator">-</span>image <span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="方法2-docker-in-docker" tabindex="-1"><a class="header-anchor" href="#方法2-docker-in-docker" aria-hidden="true">#</a> <strong>方法2：Docker In Docker</strong></h3><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/dmeba6c1ss.png" alt="dmeba6c1ss"></p><p>此方法实际上在容器内部创建一个子容器。仅当您确实要在容器中包含容器和图像时才使用此方法。否则，我建议您使用第一种方法。为此，您只需要使用带有<code>dind</code>标签的官方docker镜像即可。该dind映像使用Docker所需的实用程序进行制作以在Docker容器中运行。</p><p>请按照以下步骤测试安装程序。</p><blockquote><p>注意：这要求您的容器以特权模式运行。</p></blockquote><p>步骤1：建立<code>dind-test</code>以<code>docker:dind</code>图片命名的容器</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker run <span class="token operator">--</span>privileged <span class="token operator">-</span>d <span class="token operator">--</span>name dind<span class="token operator">-</span>test docker<span class="token operator">:</span>dind
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>步骤2：使用exec登录到容器。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker exec <span class="token operator">-</span>it dind<span class="token operator">-</span>test <span class="token operator">/</span>bin<span class="token operator">/</span>sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，从以前的方法执行步骤2到4，并验证docker命令行说明和映像构建。</p><h3 id="方法3-使用sysbox运行时的docker中的docker" tabindex="-1"><a class="header-anchor" href="#方法3-使用sysbox运行时的docker中的docker" aria-hidden="true">#</a> <strong>方法3：使用Sysbox运行时的Docker中的Docker</strong></h3><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/2pof19fepv.png" alt="2pof19fepv"></p><p>方法1和2在安全方面有一些缺点，因为在特权模式下运行容器。Nestybox尝试通过使用sysbox Docker运行时来解决该问题。</p><p>如果使用Nestybox sysbox运行时创建容器，则它可以在能够运行systemd，docker，kubernetes的容器内创建虚拟环境，而无需特权访问基础主机系统。解释sysbox需要足够的理解力，因此我不在本文的讨论范围之内。请参考此页面以全面了解sysbox。</p><p>步骤1：安装sysbox运行时环境。请参阅此页面以获取有关安装sysbox运行时的最新官方说明。</p><p>第2步：一旦拥有sysbox运行时可用，您要做的就是使用sysbox运行时标志启动docker容器，如下所示。在这里，我们使用的是官方docker dind映像。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker run <span class="token operator">--</span>runtime<span class="token operator">=</span>sysbox<span class="token operator">-</span>runc <span class="token operator">--</span>name sysbox<span class="token operator">-</span>dind <span class="token operator">-</span>d docker<span class="token operator">:</span>dind
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>步骤3：现在将exec会话带到sysbox-dind容器。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>docker exec <span class="token operator">-</span>it sysbox<span class="token operator">-</span>dind <span class="token operator">/</span>bin<span class="token operator">/</span>sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，您可以尝试使用Dockerfile构建映像，如先前方法所示。</p><h2 id="关键注意事项" tabindex="-1"><a class="header-anchor" href="#关键注意事项" aria-hidden="true">#</a> <strong>关键注意事项</strong></h2><ol><li>仅在必要时在Docker中使用Docker。在将任何工作流程迁移到Docker-in-Docker方法之前，请进行足够的测试。</li><li>在特权模式下使用容器时，请确保您已获得企业安全团队有关计划执行的必要批准。</li><li>在带有kubernetes容器的Docker中使用Docker时，存在一些挑战。请参阅此博客以了解更多信息。</li><li>如果您打算使用Nestybox（Sysbox），请确保已通过企业架构师/安全团队的测试和批准。</li></ol><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> <strong>常见问题</strong></h2><p>这是Docker问题中一些经常问到的Docker。</p><h3 id="在docker中运行docker安全吗" tabindex="-1"><a class="header-anchor" href="#在docker中运行docker安全吗" aria-hidden="true">#</a> <strong>在Docker中运行Docker安全吗？</strong></h3><p>使用<code>docker.sock</code>和<code>dind</code>方法在docker中运行docker的安全性较差，因为它具有对docker守护程序的完全特权</p><h3 id="如何在jenkins中的docker中运行docker" tabindex="-1"><a class="header-anchor" href="#如何在jenkins中的docker中运行docker" aria-hidden="true">#</a> <strong>如何在Jenkins中的docker中运行docker？</strong></h3><p>您可以使用Jenkins动态docker代理设置并将docker.sock安装到代理容器，以从代理容器内执行docker命令。</p>`,61);function u(v,m){const s=o("ExternalLinkIcon");return r(),c("div",null,[i,e("blockquote",null,[e("p",null,[a("转载自："),e("a",l,[a("如何在Docker容器中运行Docker 3种方法"),p(s)])])]),k])}const h=n(t,[["render",u],["__file","docker-docker.html.vue"]]);export{h as default};
