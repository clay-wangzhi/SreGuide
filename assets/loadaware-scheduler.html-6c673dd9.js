const e=JSON.parse('{"key":"v-cb1a630c","path":"/cloudnative/best-practice/loadaware-scheduler.html","title":"K8s 负载感知调度实践（koordinator & crane）","lang":"zh-CN","frontmatter":{"isOriginal":true,"category":"云原生","tag":["Kubernetes"],"description":"K8s 负载感知调度实践（koordinator &amp; crane） 上篇 “深入了解 kube-scheduler” ，已经知道 kube-scheduler 的工作流程，以及如何实现自定义插件。koordinator 和 crane 都是基于Scheduler Framework 进行实现的 负载感知插件。本文不再赘述，感兴趣可以看上篇文章。 背景 原生 Kubernetes 调度器仅基于资源的 Request 进行调度，在生产环境资源的真实使用率和申请率往往相差巨大，造成资源浪费的同时也会造成节点的负载不均衡。","head":[["meta",{"property":"og:url","content":"https://clay-wangzhi.com/cloudnative/best-practice/loadaware-scheduler.html"}],["meta",{"property":"og:site_name","content":"SRE运维进阶之路"}],["meta",{"property":"og:title","content":"K8s 负载感知调度实践（koordinator & crane）"}],["meta",{"property":"og:description","content":"K8s 负载感知调度实践（koordinator &amp; crane） 上篇 “深入了解 kube-scheduler” ，已经知道 kube-scheduler 的工作流程，以及如何实现自定义插件。koordinator 和 crane 都是基于Scheduler Framework 进行实现的 负载感知插件。本文不再赘述，感兴趣可以看上篇文章。 背景 原生 Kubernetes 调度器仅基于资源的 Request 进行调度，在生产环境资源的真实使用率和申请率往往相差巨大，造成资源浪费的同时也会造成节点的负载不均衡。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-24T09:55:00.000Z"}],["meta",{"property":"article:author","content":"Clay"}],["meta",{"property":"article:tag","content":"Kubernetes"}],["meta",{"property":"article:modified_time","content":"2024-10-24T09:55:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"K8s 负载感知调度实践（koordinator & crane）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-24T09:55:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Clay\\",\\"url\\":\\"https://clay-wangzhi.com\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"开源方案对比 koordinator VS crane","slug":"开源方案对比-koordinator-vs-crane","link":"#开源方案对比-koordinator-vs-crane","children":[]},{"level":2,"title":"koordinator 使用实践","slug":"koordinator-使用实践","link":"#koordinator-使用实践","children":[]},{"level":2,"title":"测试","slug":"测试","link":"#测试","children":[]}],"git":{"createdTime":1729763700000,"updatedTime":1729763700000,"contributors":[{"name":"clay-wangzhi","email":"clay.wangzhi@gmail.com","commits":1}]},"readingTime":{"minutes":3.08,"words":924},"filePathRelative":"cloudnative/best-practice/loadaware-scheduler.md","localizedDate":"2024年10月24日","excerpt":"<h1> K8s 负载感知调度实践（koordinator &amp; crane）</h1>\\n<p>上篇 “深入了解 kube-scheduler” ，已经知道 kube-scheduler 的工作流程，以及如何实现自定义插件。koordinator 和 crane 都是基于Scheduler Framework 进行实现的 负载感知插件。本文不再赘述，感兴趣可以看上篇文章。</p>\\n<h2> 背景</h2>\\n<p>原生 Kubernetes 调度器仅基于资源的 Request 进行调度，在生产环境资源的真实使用率和申请率往往相差巨大，造成<strong>资源浪费</strong>的同时也会造成节点的负<strong>载不均衡</strong>。</p>","copyright":{"author":"Clay"},"autoDesc":true}');export{e as data};
