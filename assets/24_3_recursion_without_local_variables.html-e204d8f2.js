const i=JSON.parse('{"key":"v-092fc61e","path":"/code/shell/part5/24_3_recursion_without_local_variables.html","title":"24.3 不使用局部变量的递归","lang":"zh-CN","frontmatter":{"author":"LinuxStory","category":"Linux","tag":["Bash"],"description":"24.3 不使用局部变量的递归 即使不适用局部变量，函数也可以递归的调用自身。 斐波那契序列 #!/bin/bash # fibo.sh : 斐波那契序列 (递归) # 作者: M. Cooper # License: GPL3 # ----------算法-------------- # Fibo(0) = 0 # Fibo(1) = 1 # else # Fibo(j) = Fibo(j-1) + Fibo(j-2) # --------------------------------- MAXTERM=15 # 要产生的计算次数。 MINIDX=2 # 如果下标小于2，那么 Fibo(idx) = idx. Fibonacci () { idx=$1 # 不需要是局部变量，为什么？ if [ \\"$idx\\" -lt \\"$MINIDX\\" ] then echo \\"$idx\\" # 前两个下标是0和1 ... 从上面的算法可以看出来。 else (( --idx )) # j-1 term1=$( Fibonacci $idx ) # Fibo(j-1) (( --idx )) # j-2 term2=$( Fibonacci $idx ) # Fibo(j-2) echo $(( term1 + term2 )) fi # 一个丑陋的实现 # C语言里，一个更加优雅的斐波那契递归实现 #+ 是一个简单的只需要7-10代码的算法翻译。 } for i in $(seq 0 $MAXTERM) do # 计算 $MAXTERM+1 次. FIBO=$(Fibonacci $i) echo -n \\"$FIBO \\" done # 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 # 要花费一段时间，不是么？ 一个递归脚本是有些慢的。 echo exit 0","head":[["meta",{"property":"og:url","content":"https://clay-wangzhi.com/code/shell/part5/24_3_recursion_without_local_variables.html"}],["meta",{"property":"og:site_name","content":"SRE运维进阶之路"}],["meta",{"property":"og:title","content":"24.3 不使用局部变量的递归"}],["meta",{"property":"og:description","content":"24.3 不使用局部变量的递归 即使不适用局部变量，函数也可以递归的调用自身。 斐波那契序列 #!/bin/bash # fibo.sh : 斐波那契序列 (递归) # 作者: M. Cooper # License: GPL3 # ----------算法-------------- # Fibo(0) = 0 # Fibo(1) = 1 # else # Fibo(j) = Fibo(j-1) + Fibo(j-2) # --------------------------------- MAXTERM=15 # 要产生的计算次数。 MINIDX=2 # 如果下标小于2，那么 Fibo(idx) = idx. Fibonacci () { idx=$1 # 不需要是局部变量，为什么？ if [ \\"$idx\\" -lt \\"$MINIDX\\" ] then echo \\"$idx\\" # 前两个下标是0和1 ... 从上面的算法可以看出来。 else (( --idx )) # j-1 term1=$( Fibonacci $idx ) # Fibo(j-1) (( --idx )) # j-2 term2=$( Fibonacci $idx ) # Fibo(j-2) echo $(( term1 + term2 )) fi # 一个丑陋的实现 # C语言里，一个更加优雅的斐波那契递归实现 #+ 是一个简单的只需要7-10代码的算法翻译。 } for i in $(seq 0 $MAXTERM) do # 计算 $MAXTERM+1 次. FIBO=$(Fibonacci $i) echo -n \\"$FIBO \\" done # 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 # 要花费一段时间，不是么？ 一个递归脚本是有些慢的。 echo exit 0"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-19T13:08:31.000Z"}],["meta",{"property":"article:author","content":"LinuxStory"}],["meta",{"property":"article:tag","content":"Bash"}],["meta",{"property":"article:modified_time","content":"2023-04-19T13:08:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"24.3 不使用局部变量的递归\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-19T13:08:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LinuxStory\\"}]}"]]},"headers":[{"level":2,"title":"斐波那契序列","slug":"斐波那契序列","link":"#斐波那契序列","children":[]}],"git":{"createdTime":1681909711000,"updatedTime":1681909711000,"contributors":[{"name":"clay-wangzhi","email":"clay.wangzhi@gmail.com","commits":1}]},"readingTime":{"minutes":2.95,"words":884},"filePathRelative":"code/shell/part5/24_3_recursion_without_local_variables.md","localizedDate":"2023年4月19日","excerpt":"<h1> 24.3 不使用局部变量的递归</h1>\\n<p>即使不适用局部变量，函数也可以递归的调用自身。</p>\\n<h2> 斐波那契序列</h2>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>#!/bin/bash\\n# fibo.sh : 斐波那契序列 (递归)\\n# 作者: M. Cooper\\n# License: GPL3\\n\\n# ----------算法--------------\\n# Fibo(0) = 0\\n# Fibo(1) = 1\\n# else\\n#   Fibo(j) = Fibo(j-1) + Fibo(j-2)\\n# ---------------------------------\\n\\nMAXTERM=15       # 要产生的计算次数。\\nMINIDX=2         # 如果下标小于2，那么 Fibo(idx) = idx.\\n\\nFibonacci ()\\n{\\n    idx=$1   # 不需要是局部变量，为什么？\\n    if [ \\"$idx\\" -lt \\"$MINIDX\\" ]\\n    then\\n        echo \\"$idx\\"  # 前两个下标是0和1 ... 从上面的算法可以看出来。\\n    else\\n        (( --idx ))  # j-1\\n        term1=$( Fibonacci $idx )   #  Fibo(j-1)\\n        (( --idx ))  # j-2\\n        term2=$( Fibonacci $idx )   #  Fibo(j-2)\\n        echo $(( term1 + term2 ))\\n    fi\\n    #  一个丑陋的实现\\n    #  C语言里，一个更加优雅的斐波那契递归实现\\n    #+ 是一个简单的只需要7-10代码的算法翻译。\\n}\\n\\nfor i in $(seq 0 $MAXTERM)\\ndo  # 计算 $MAXTERM+1 次.\\n    FIBO=$(Fibonacci $i)\\n    echo -n \\"$FIBO \\"\\ndone\\n# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\\n# 要花费一段时间，不是么？ 一个递归脚本是有些慢的。\\n\\necho\\n\\nexit 0\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{"author":"LinuxStory"},"autoDesc":true}');export{i as data};
