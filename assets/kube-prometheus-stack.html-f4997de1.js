import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as p,c,b as a,d as e,a as n,e as t}from"./app-a7feade7.js";const i={},l=t('<h1 id="prometheus-operator-安装配置" tabindex="-1"><a class="header-anchor" href="#prometheus-operator-安装配置" aria-hidden="true">#</a> Prometheus Operator 安装配置</h1><h2 id="一、概述" tabindex="-1"><a class="header-anchor" href="#一、概述" aria-hidden="true">#</a> 一、概述</h2><p>首先Prometheus整体监控结构略微复杂，一个个部署并不简单。另外监控Kubernetes就需要访问内部数据，必定需要进行认证、鉴权、准入控制，</p><p>那么这一整套下来将变得难上加难，而且还需要花费一定的时间，如果你没有特别高的要求，还是建议选用开源比较好的一些方案。</p><p>在k8s初期使用Heapster+cAdvisor方式监控，这是Prometheus Operator出现之前的k8s监控方案。后来出现了Prometheus Operator，但是目前Prometheus Operator已经不包含完整功能，完整的解决方案已经变为kube-prometheus。项目地址为：</p><p>https://github.com/prometheus-operator/kube-prometheus</p><p>关于kube-prometheus目前应该是开源最好的方案了，该存储库收集Kubernetes清单，Grafana仪表板和Prometheus规则，以及文档和脚本，以使用Prometheus Operator 通过Prometheus提供易于操作的端到端Kubernetes集群监视。以容器的方式部署到k8s集群，而且还可以自定义配置，非常的方便。</p><p>首先我们先来了解下 Prometheus Operator 的架构图：</p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/20200410141511.png" alt="promtheus opeator" style="zoom:50%;"><p>上图是 Prometheus-Operator 官方提供的架构图，各组件以不同的方式运行在 Kubernetes 集群中，其中 Operator 是最核心的部分，作为一个控制器，他会去创建 Prometheus、ServiceMonitor、AlertManager 以及 PrometheusRule 等 CRD 资源对象，然后会一直 Watch 并维持这些资源对象的状态。</p><p>在最新版本的 Operator 中提供了一下几个 CRD 资源对象：</p><ul><li><code>Prometheus</code></li><li><code>Alertmanager</code></li><li><code>ServiceMonitor</code></li><li><code>PodMonitor</code></li><li><code>Probe</code></li><li><code>ThanosRuler</code></li><li><code>PrometheusRule</code></li><li><code>AlertmanagerConfig</code></li></ul><p>这里面我们用的最多的三个 crd 就是 PodMonitor、ServiceMonitor、PrometheusRule</p><h3 id="prometheus" tabindex="-1"><a class="header-anchor" href="#prometheus" aria-hidden="true">#</a> Prometheus</h3><p>该 CRD 声明定义了 Prometheus 期望在 Kubernetes 集群中运行的配置，提供了配置选项来配置副本、持久化、报警实例等。</p><p>对于每个 Prometheus CRD 资源，Operator 都会以 StatefulSet 形式在相同的命名空间下部署对应配置的资源，Prometheus Pod 的配置是通过一个包含 Prometheus 配置的名为 <code>&lt;prometheus-name&gt;</code> 的 Secret 对象声明挂载的。</p><p>该 Secret 以 prometheus.yaml.gz 为 key 的方式保存使用配置文件。</p><p>该 CRD 根据标签选择来指定部署的 Prometheus 实例应该覆盖哪些 <code>ServiceMonitors</code>，然后 Operator 会根据包含的 ServiceMonitors 生成配置，并在包含配置的 Secret 中进行更新。</p><p>如果未提供对 <code>ServiceMonitor</code> 的选择，则 Operator 会将 Secret 的管理留给用户，这样就可以提供自定义配置，同时还能享受 Operator 管理 Operator 的设置能力。</p><h3 id="alertmanager" tabindex="-1"><a class="header-anchor" href="#alertmanager" aria-hidden="true">#</a> Alertmanager</h3><p>该 CRD 定义了在 Kubernetes 集群中运行的 Alertmanager 的配置，同样提供了多种配置，包括持久化存储。</p><p>对于每个 Alertmanager 资源，Operator 都会在相同的命名空间中部署一个对应配置的 StatefulSet，Alertmanager Pods 被配置为包含一个名为 <code>&lt;alertmanager-name&gt;</code> 的 Secret，该 Secret 以 <code>alertmanager.yaml</code> 为 key 的方式保存使用的配置文件。</p><p>当有两个或更多配置的副本时，Operator 会在<strong>高可用</strong>模式下运行 Alertmanager 实例。</p><h3 id="thanosruler" tabindex="-1"><a class="header-anchor" href="#thanosruler" aria-hidden="true">#</a> ThanosRuler</h3><p>该 CRD 定义了一个 <code>Thanos Ruler</code> 组件的配置，以方便在 Kubernetes 集群中运行。通过 Thanos Ruler，可以跨多个Prometheus 实例处理记录和警报规则。</p>',25),d=a("code",null,"queryEndpoint",-1),u=a("code",null,"Thanos Queriers",-1),h=a("code",null,"queryEndpoints",-1),m=a("code",null,"--query",-1),k={href:"https://prometheus-operator.dev/docs/operator/design/thanos.md",target:"_blank",rel:"noopener noreferrer"},b=t(`<h3 id="servicemonitor" tabindex="-1"><a class="header-anchor" href="#servicemonitor" aria-hidden="true">#</a> ServiceMonitor</h3><p>该 CRD 定义了如何监控一组动态的服务，使用标签选择来定义哪些 Service 被选择进行监控。这可以让团队制定一个如何暴露监控指标的规范，然后按照这些规范自动发现新的服务，而无需重新配置。</p><p>为了让 Prometheus 监控 Kubernetes 内的任何应用，需要存在一个 Endpoints 对象，Endpoints 对象本质上是IP地址的列表，通常 Endpoints 对象是由 Service 对象来自动填充的，Service 对象通过标签选择器匹配 Pod，并将其添加到Endpoints 对象中。一个 Service 可以暴露一个或多个端口，这些端口由多个 Endpoints 列表支持，这些端点一般情况下都是指向一个 Pod。</p><p>Prometheus Operator 引入的这个 ServiceMonitor 对象就会发现这些 Endpoints 对象，并配置 Prometheus 监控这些 Pod。<code>ServiceMonitorSpec</code> 的 endpoints 部分就是用于配置这些 Endpoints 的哪些端口将被 scrape 指标的。</p><blockquote><p>⚠️ endpoints（小写）是 ServiceMonitor CRD 中的字段，而 Endpoints（大写）是 Kubernetes 的一种对象。</p></blockquote><p>ServiceMonitors 以及被发现的目标都可以来自任何命名空间，这对于允许跨命名空间监控的场景非常重要。使用 <code>PrometheusSpec</code> 的 <code>ServiceMonitorNamespaceSelector</code>，可以限制各自的 Prometheus 服务器选择的 ServiceMonitors 的命名空间。使用 <code>ServiceMonitorSpec</code> 的 <code>namespaceSelector</code>，可以限制 Endpoints 对象被允许从哪些命名空间中发现，要在所有命名空间中发现目标，<code>namespaceSelector</code> 必须为空：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespaceSelector</span><span class="token punctuation">:</span>
    <span class="token key atrule">any</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="podmonitor" tabindex="-1"><a class="header-anchor" href="#podmonitor" aria-hidden="true">#</a> PodMonitor</h3><p>该 CRD 用于定义如何监控一组动态 pods，使用标签选择来定义哪些 pods 被选择进行监控。同样团队中可以制定一些规范来暴露监控的指标。</p><p>Pod 是一个或多个容器的集合，可以在一些端口上暴露 Prometheus 指标。</p><p>由 Prometheus Operator 引入的 PodMonitor 对象会发现这些 Pod，并为 Prometheus 服务器生成相关配置，以便监控它们。</p><p><code>PodMonitorSpec</code> 中的 <code>PodMetricsEndpoints</code> 部分，用于配置 Pod 的哪些端口将被 scrape 指标，以及使用哪些参数。</p><p>PodMonitors 和发现的目标可以来自任何命名空间，这同样对于允许跨命名空间的监控用例是很重要的。使用 <code>PodMonitorSpec</code> 的 <code>namespaceSelector</code>，可以限制 Pod 被允许发现的命名空间，要在所有命名空间中发现目标，<code>namespaceSelector</code> 必须为空：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">namespaceSelector</span><span class="token punctuation">:</span>
    <span class="token key atrule">any</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>PodMonitor</code> 和 <code>ServieMonitor</code> 最大的区别就是不需要有对应的 Service。</p><h3 id="probe" tabindex="-1"><a class="header-anchor" href="#probe" aria-hidden="true">#</a> Probe</h3>`,16),v=a("code",null,"Probe",-1),g=a("code",null,"prober",-1),f={href:"https://github.com/prometheus/blackbox_exporter/",target:"_blank",rel:"noopener noreferrer"},y=t(`<h3 id="prometheusrule" tabindex="-1"><a class="header-anchor" href="#prometheusrule" aria-hidden="true">#</a> PrometheusRule</h3><p>用于配置 Prometheus 的 Rule 规则文件，包括 recording rules 和 alerting，可以自动被 Prometheus 加载。</p><h3 id="alertmanagerconfig" tabindex="-1"><a class="header-anchor" href="#alertmanagerconfig" aria-hidden="true">#</a> AlertmanagerConfig</h3><p>在以前的版本中要配置 Alertmanager 都是通过 Configmap 来完成的，在 v0.43 版本后新增该 CRD，可以将 Alertmanager 的配置分割成不同的子对象进行配置，允许将报警路由到自定义 Receiver 上，并配置抑制规则。</p><p><code>AlertmanagerConfig</code> 可以在命名空间级别上定义，为 Alertmanager 提供一个聚合的配置。</p><p>这样我们要在集群中监控什么数据，就变成了直接去操作 Kubernetes 集群的资源对象了，是这样比之前手动的方式就方便很多了。</p><h2 id="二、安装" tabindex="-1"><a class="header-anchor" href="#二、安装" aria-hidden="true">#</a> 二、安装</h2><p>我们可以使用 Prometheus 社区维护的 Helm 图表来部署 Prometheus Operator，他进一步简化了安装，默认封装好了 etcd，scheduler，controller-manager 的 svc，拆分了 PrometheusRule 等，所以我们安装 Prometheus Operator 可以用 helm chart，后续的维护 直接新建 crd 的yaml 文件进行更新。</p><p>https://github.com/prometheus-community/helm-charts</p><h3 id="helm-获取压缩包" tabindex="-1"><a class="header-anchor" href="#helm-获取压缩包" aria-hidden="true">#</a> Helm 获取压缩包</h3><p>添加 helm repo</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>helm repo <span class="token function">add</span> prometheus-community https://prometheus-community.github.io/helm-charts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下拉压缩包</p><blockquote><p>⚠️ kube-prometheus-stack 版本请根据 k8s 版本具体选择，否则会出现不兼容问题</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>helm pull prometheus-community/kube-prometheus-stack <span class="token parameter variable">--version</span> <span class="token number">23.3</span>.2
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> kube-prometheus-stack-23.3.2.tgz
<span class="token builtin class-name">cd</span> kube-prometheus-stack/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="prometheus-安装配置" tabindex="-1"><a class="header-anchor" href="#prometheus-安装配置" aria-hidden="true">#</a> Prometheus 安装配置</h3><p>为 prometheus 创建 Namespace</p><blockquote><p>ns 为 cattle-prometheus 的原因，是方便 rancher 收集 做可视化，如无需求，可自定义 ns</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl create namespace cattle-prometheus
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改 kube-proxy 的configmap</p><blockquote><p>将 metricsBindAddress 修改为 &quot;0.0.0.0:10249&quot;</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl <span class="token parameter variable">-n</span> kube-system edit configmaps kube-proxy
kubectl rollout restart ds kube-proxy <span class="token parameter variable">-n</span> kube-system
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 现状 本来就使用的https ，所以要新增认证，如果是新建的，可以使用http，具体步骤见下 &quot;etcd http 模式&quot;</p><h4 id="etcd-https-模式" tabindex="-1"><a class="header-anchor" href="#etcd-https-模式" aria-hidden="true">#</a> etcd https 模式</h4><p>新增 etcd secret</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl create secret generic etcd-certs <span class="token parameter variable">-n</span> cattle-prometheus --from-file<span class="token operator">=</span>/etc/kubernetes/pki/etcd/ca.crt --from-file<span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.crt --from-file<span class="token operator">=</span>/etc/kubernetes/pki/etcd/healthcheck-client.key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>部署</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>helm <span class="token function">install</span> monitoring <span class="token parameter variable">-n</span> cattle-prometheus  <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.serviceMonitor.scheme</span><span class="token operator">=</span>https <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.serviceMonitor.caFile</span><span class="token operator">=</span>/etc/prometheus/secrets/etcd-certs/ca.crt <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.serviceMonitor.certFile</span><span class="token operator">=</span>/etc/prometheus/secrets/etcd-certs/healthcheck-client.crt <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.serviceMonitor.keyFile</span><span class="token operator">=</span>/etc/prometheus/secrets/etcd-certs/healthcheck-client.key <span class="token parameter variable">--set</span> <span class="token assign-left variable">prometheus.prometheusSpec.secrets</span><span class="token operator">=</span><span class="token punctuation">{</span>etcd-certs<span class="token punctuation">}</span> <span class="token parameter variable">--set</span> <span class="token assign-left variable">prometheusOperator.admissionWebhooks.patch.image.sha</span><span class="token operator">=</span>null ./
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 node 上下拉镜像</p><p>由于镜像在国外<code>kube-state-metrics:v2.2.4</code>、<code>kube-webhook-certgen:v1.0</code>，我拉取下来放到 国内可达的仓库地址</p><h4 id="etcd-http-模式" tabindex="-1"><a class="header-anchor" href="#etcd-http-模式" aria-hidden="true">#</a> etcd http 模式</h4>`,31),P={href:"http://ip:2381/",target:"_blank",rel:"noopener noreferrer"},x={href:"http://127.0.0.1:2381/",target:"_blank",rel:"noopener noreferrer"},_={href:"http://127.0.0.1:2381%2Chttps/",target:"_blank",rel:"noopener noreferrer"},S=t(`<p>部署</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>helm <span class="token function">install</span> monitoring <span class="token parameter variable">-n</span> cattle-prometheus <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.service.port</span><span class="token operator">=</span><span class="token number">2381</span> <span class="token parameter variable">--set</span> <span class="token assign-left variable">kubeEtcd.service.targetPort</span><span class="token operator">=</span><span class="token number">2381</span> <span class="token parameter variable">--set</span> <span class="token assign-left variable">prometheusOperator.admissionWebhooks.patch.image.sha</span><span class="token operator">=</span>null ./
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="查找-grafana-admin-账户密码" tabindex="-1"><a class="header-anchor" href="#查找-grafana-admin-账户密码" aria-hidden="true">#</a> 查找 grafana admin 账户密码</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>kubectl -n cattle-prometheus get secrets monitoring-grafana -o jsonpath=&quot;{.data.admin-password}&quot; | base64 --decode ; echo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="三、配置报警" tabindex="-1"><a class="header-anchor" href="#三、配置报警" aria-hidden="true">#</a> 三、配置报警</h2><p>为了统一发送告警的位置，建议 k8s 外部搭建 alertmanager 高可用集群，告警组分类，应该按照 appid 的维度进行告警，告警规则应该关联上 appid 的标签</p><p>在 prometheus 所在的 namespace 下创建 alertmanager 的外部服务</p><p>创建外部服务映射到 k8s:</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager<span class="token punctuation">-</span>ext
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> cattle<span class="token punctuation">-</span>prometheus
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9093</span>
 
<span class="token punctuation">---</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Endpoints
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager<span class="token punctuation">-</span>ext
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> cattle<span class="token punctuation">-</span>prometheus
<span class="token key atrule">subsets</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">addresses</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> xx
      <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> xx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9093</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改prometheus使用的AlertManger</p><p><code>kubectl -n cattle-prometheus edit prometheus monitoring-kube-prometheus-prometheus</code></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">alerting</span><span class="token punctuation">:</span>
    <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v2
      <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager<span class="token punctuation">-</span>ext
      <span class="token key atrule">namespace</span><span class="token punctuation">:</span> cattle<span class="token punctuation">-</span>prometheus
      <span class="token key atrule">pathPrefix</span><span class="token punctuation">:</span> /
      <span class="token key atrule">port</span><span class="token punctuation">:</span> web
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>prometheus-alert-history 可以用开源项目 alertsnitch</strong></p><h2 id="四、问题处理" tabindex="-1"><a class="header-anchor" href="#四、问题处理" aria-hidden="true">#</a> 四、问题处理</h2><ol><li>controller-manager ，scheduler targes 收集异常 可以注释 manifest 中的 --port=0 参数</li></ol><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2><ul><li>https://tech.meipian.cn/k8sjian-kong-zhong-ji-jie-jue-fang-an/</li><li>https://www.qikqiak.com/k8strain2/monitor/operator/install/</li><li>https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/alerting.md</li></ul>`,17);function M(R,E){const s=o("ExternalLinkIcon");return p(),c("div",null,[l,a("p",null,[e("一个 ThanosRuler 实例至少需要一个 "),d,e("，它指向 "),u,e(" 或 Prometheus 实例的位置。"),h,e(" 用于配置 Thanos 运行时的 "),m,e(" 参数，更多信息也可以在 "),a("a",k,[e("Thanos 文档"),n(s)]),e("中找到。")]),b,a("p",null,[e("该 CRD 用于定义如何监控一组 Ingress 和静态目标。除了 target 之外，"),v,e(" 对象还需要一个 "),g,e("，它是监控的目标并为 Prometheus 提供指标的服务。例如可以通过使用 "),a("a",f,[e("blackbox-exporter"),n(s)]),e(" 来提供这个服务。")]),y,a("p",null,[e("将 --listen-metrics-urls= 值 改为 "),a("a",P,[e("http://ip:2381"),n(s)]),e("，要新增，不要修改127.0.0.1，实例")]),a("p",null,[e("# - --listen-metrics-urls="),a("a",x,[e("http://127.0.0.1:2381"),n(s)]),e(" - --listen-metrics-urls="),a("a",_,[e("http://127.0.0.1:2381,https://10.100.142.163:2381"),n(s)])]),S])}const C=r(i,[["render",M],["__file","kube-prometheus-stack.html.vue"]]);export{C as default};
