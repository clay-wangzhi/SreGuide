import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,e as a}from"./app-d870e103.js";const t={},p=a(`<p>subprocess模块允许你去创建一个新的进程让其执行另外的程序，并与它进行通信，获取标准的输入、标准输</p><p>出、标准错误以及返回码等。(使用这个模块之前先导入import subprocess)。</p><p>subprocess模块打算来替代几个过时的模块和函数，比如： os.system, os.spawn*, os.popen*, popen2.*命令。</p><p>让我们来看一下subprocess 有哪些不同的函数.</p><h2 id="subprocess-call-subprocess-check-call-subprocess-check-output" tabindex="-1"><a class="header-anchor" href="#subprocess-call-subprocess-check-call-subprocess-check-output" aria-hidden="true">#</a> subprocess.call(), subprocess.check_call(), subprocess.check_output()</h2><p>执行由参数提供的命令.</p><p>我们可以用数组作为参数运行命令,也可以用字符串作为参数运行命令(通过设置参数shell=True)</p><p>注意,参数shell默认为False</p><p>我们用subprocess.call()来做一个查看文件的例子:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>subprocess<span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-a&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将上边的例子,把shell设置为True,就可以使用字符串了:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>subprocess<span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token string">&quot;ls -a&quot;</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="subprocess-call" tabindex="-1"><a class="header-anchor" href="#subprocess-call" aria-hidden="true">#</a> subprocess.call()</h3><p>父进程等待子进程完成</p><p>返回退出信息(returncode，相当于Linux exit code)</p><h3 id="subprocess-check-call" tabindex="-1"><a class="header-anchor" href="#subprocess-check-call" aria-hidden="true">#</a> subprocess.check_call()</h3><p>父进程等待子进程完成</p><p>返回0</p><p>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode</p><p>属性，可用try…except…来检查。</p><h3 id="subprocess-check-output" tabindex="-1"><a class="header-anchor" href="#subprocess-check-output" aria-hidden="true">#</a> subprocess.check_output()</h3><p>父进程等待子进程完成</p><p>返回子进程向标准输出的输出结果</p><p>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode</p><p>属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。</p><p>这三个函数的使用方法相类似，下面来以subprocess.call()举例说明:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> subprocess

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    retcode <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token string">&quot;df -h&quot;</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>retcode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#retcode = 0</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="subprocess-popen" tabindex="-1"><a class="header-anchor" href="#subprocess-popen" aria-hidden="true">#</a> subprocess.Popen()</h2><p>class Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)</p><p>实际上，上面的几个函数都是基于Popen()的封装(wrapper)。这些封装的目的在于让我们容易使用子进程。当我</p><p>们想要更个性化我们的需求的时候，就要转向Popen类，该类生成的对象用来代表子进程。</p><p>与上面的封装不同，Popen对象创建后，主程序不会自动等待子进程完成。我们必须调用对象的wait()方法，父进</p><p>程才会等待 (也就是阻塞block)，举例：</p><p>代码如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; child = subprocess.Popen([&#39;ping&#39;,&#39;-c&#39;,&#39;4&#39;,&#39;www.baidu.com&#39;])
&gt;&gt;&gt; print(&#39;parent process&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import subprocess
child = subprocess.Popen([&#39;ping&#39;,&#39;-c&#39;,&#39;4&#39;,&#39;www.baidu.com&#39;])
print(&#39;parent process&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从运行结果中看到，父进程在开启子进程之后并没有等待child的完成，而是直接运行print。</p><p>对比等待的情况:</p><p>代码如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; child = subprocess.Popen(&#39;ping -c 4 www.baidu.com&#39;,shell=True)
&gt;&gt;&gt; child.wait()
&gt;&gt;&gt; print(&#39;parent process&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import subprocess
child = subprocess.Popen(&#39;ping -c 4 www.baidu.com&#39;,shell=True)
child.wait()
print(&#39;parent process&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从运行结果中看到，父进程在开启子进程之后并等待child的完成后，再运行print。</p><p>此外，你还可以在父进程中对子进程进行其它操作，比如我们上面例子中的child对象:代码如下:</p><ul><li>child.poll() # 检查子进程状态</li><li>child.kill() # 终止子进程</li><li>child.send_signal() # 向子进程发送信号</li><li>child.terminate() # 终止子进程</li></ul><p>子进程的PID存储在child.pid</p><h2 id="子进程的文本流控制" tabindex="-1"><a class="header-anchor" href="#子进程的文本流控制" aria-hidden="true">#</a> 子进程的文本流控制</h2><p>子进程的标准输入、标准输出和标准错误如下属性分别表示:</p><p>代码如下:</p><ul><li>child.stdin</li><li>child.stdout</li><li>child.stderr</li></ul><p>可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进</p><p>程的输入和输出连接在一起，构成管道(pipe)，如下2个例子：</p><p>代码如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; child1 = subprocess.Popen([&quot;ls&quot;,&quot;-l&quot;], stdout=subprocess.PIPE)
&gt;&gt;&gt; print child1.stdout.read(),
&gt;&gt;&gt; #或者child1.communicate()
&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; child1 = subprocess.Popen([&quot;cat&quot;,&quot;/etc/passwd&quot;], stdout=subprocess.PIPE)
&gt;&gt;&gt; child2 = subprocess.Popen([&quot;grep&quot;,&quot;0:0&quot;],stdin=child1.stdout, stdout=subprocess.PIPE)
&gt;&gt;&gt; out = child2.communicate()
&gt;&gt;&gt; print(out)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>subprocess.PIPE实际上为文本流提供一个缓存区。</p><p>child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。</p><p>child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。</p><blockquote><p>注意：communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成</p></blockquote><p>wait()方法可能会造成死锁, 那死锁问题如何避免呢？</p><p>官方文档里推荐使用 Popen.communicate()。</p><p>这个方法会把输出放在内存，而不是管道里，所以这时候上限就和内存大小有关了，一般不会有问题。</p><p>而且如果要获得程序返回值，可以在调用 Popen.communicate() 之后取 Popen.returncode 的值。</p><blockquote><p>结论：如果使用 subprocess.Popen，就不使用 Popen.wait()，而使用 Popen.communicate() 来等待外部程序执行结束</p></blockquote><blockquote><p>转载链接：https://blog.csdn.net/qq_34765864/article/details/91517246</p></blockquote>`,63),c=[p];function i(o,l){return e(),n("div",null,c)}const d=s(t,[["render",i],["__file","python subprocess模块的使用.html.vue"]]);export{d as default};
