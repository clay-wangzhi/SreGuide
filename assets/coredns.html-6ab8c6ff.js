import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c as i,a as n,b as e,d as a,e as t}from"./app-7c13e092.js";const c={},p=t('<h1 id="coredns-概述及运维实践" tabindex="-1"><a class="header-anchor" href="#coredns-概述及运维实践" aria-hidden="true">#</a> CoreDNS 概述及运维实践</h1><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/coredns-1.png" alt=""></p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="什么是-dns" tabindex="-1"><a class="header-anchor" href="#什么是-dns" aria-hidden="true">#</a> 什么是 DNS ?</h3><p><strong>域名系统</strong>（英语：<strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem，缩写：<strong>DNS</strong>）是互联网的一项服务。它作为将<strong>域名</strong>和<strong>IP地址</strong>相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。</p><p>DNS 不仅方便了人们访问不同的互联网服务，更为很多应用提供了，动态服务发现和全局负载均衡（Global Server Load Balance，GSLB）的机制。这样，DNS 就可以选择离用户最近的 IP 来提供服务。即使后端服务的 IP 地址发生变化，用户依然可以用相同域名来访问。</p><p>DNS 协议在 TCP/IP 栈中属于<strong>应用层</strong>，是一个典型的 客户端 - 服务器应用，客户端发起域名查询请求，服务端对请求进行应答。</p><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/image-20240428172825007.png" alt=""></p><h3 id="coredns-介绍" tabindex="-1"><a class="header-anchor" href="#coredns-介绍" aria-hidden="true">#</a> CoreDNS 介绍</h3>',9),d={href:"https://cncf.io/",target:"_blank",rel:"noopener noreferrer"},u=t('<p>DNS 服务器支持正向查找（A 和 AAAA 记录）、端口发现（SRV 记录）、反向 IP 地址发现（PTR 记录）等。</p><p>如果 Pod 的 <code>dnsPolicy</code> 设置为 <code>default</code>，则它将从 Pod 运行所在节点继承名称解析配置。 Pod 的 DNS 解析行为应该与节点相同。</p><p>如果你不想这样做，或者想要为 Pod 使用其他 DNS 配置，则可以使用 kubelet 的 <code>--resolv-conf</code> 标志。</p><h3 id="pod-的-dns-策略" tabindex="-1"><a class="header-anchor" href="#pod-的-dns-策略" aria-hidden="true">#</a> Pod 的 DNS 策略</h3><ul><li><strong>ClusterFirst</strong>：这是默认的DNS策略，意味着当Pod需要进行域名解析时，首先会查询集群内部的CoreDNS服务。通过CoreDNS来做域名解析，表示Pod的/etc/resolv.conf文件被自动配置指向kube-dns服务地址。</li><li><strong>None</strong>：使用该策略，Kubernetes会忽略集群的DNS策略。需要您提供<strong>dnsConfig</strong>字段来指定DNS配置信息，否则Pod可能无法正确解析任何域名。</li><li><strong>Default</strong>：Pod直接继承集群节点的域名解析配置。</li><li><strong>ClusterFirstWithHostNet</strong>：强制在hostNetwork网络模式下使用ClusterFirst策略（默认使用Default策略）。</li></ul><h3 id="kubernetes集群中dns域名解析原理-clusterfirst-策略" tabindex="-1"><a class="header-anchor" href="#kubernetes集群中dns域名解析原理-clusterfirst-策略" aria-hidden="true">#</a> Kubernetes集群中DNS域名解析原理（ClusterFirst 策略）</h3><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/CAEQQRiBgICHx5qL9RgiIDIwYjgyM2QwNWIzMzRiNmZiYmUwM2VmZjE2NDAwNDQy3963382_20230830144006.372.svg" alt=""></p><p>1）业务Pod（Pod Client）试图访问Nginx服务（Service Nginx）时，先会请求本地DNS配置文件（/etc/resolv.conf）中指向的DNS服务器（nameserver 172.21.0.10，即Service kube-dns）获取服务IP地址，得到解析结果为172.21.0.30的IP地址。</p><p>2）业务Pod（Pod Client）再直接发起往该IP地址的请求，请求最终经过Nginx服务（Service Nginx）转发到达后端的Nginx容器（Pod Nginx-1和Pod Nginx-2）上。</p><h2 id="运维实践" tabindex="-1"><a class="header-anchor" href="#运维实践" aria-hidden="true">#</a> 运维实践</h2><h3 id="coredns-configmap-选项" tabindex="-1"><a class="header-anchor" href="#coredns-configmap-选项" aria-hidden="true">#</a> CoreDNS ConfigMap 选项</h3>',11),k={href:"https://coredns.io/2017/07/23/corefile-explained/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>在 Kubernetes 中，CoreDNS 安装时使用如下默认 Corefile 配置：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> coredns
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">Corefile</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
    .:53 {
        errors
        health {
            lameduck 5s
        }
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
            pods insecure
            fallthrough in-addr.arpa ip6.arpa
            ttl 30
        }
        prometheus :9153
        forward . /etc/resolv.conf
        cache 30
        loop
        reload
        loadbalance
    }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),h={href:"https://coredns.io/plugins/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://coredns.io/plugins/errors/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://coredns.io/plugins/health/",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"http://localhost:8080/health",-1),_=n("code",null,"lameduck",-1),N={href:"https://coredns.io/plugins/ready/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://coredns.io/plugins/kubernetes/",target:"_blank",rel:"noopener noreferrer"},S={href:"https://coredns.io/plugins/kubernetes/",target:"_blank",rel:"noopener noreferrer"},D=t("<ul><li><p>你可以使用 <code>ttl</code> 来定制响应的 TTL。默认值是 5 秒钟。TTL 的最小值可以是 0 秒钟， 最大值为 3600 秒。将 TTL 设置为 0 可以禁止对 DNS 记录进行缓存。</p></li><li><p><code>pods insecure</code> 选项是为了与 kube-dns 向后兼容。</p></li><li><p>你可以使用 <code>pods verified</code> 选项，该选项使得仅在相同名字空间中存在具有匹配 IP 的 Pod 时才返回 A 记录。</p></li><li><p>如果你不使用 Pod 记录，则可以使用 <code>pods disabled</code> 选项。</p></li></ul>",1),C={href:"https://coredns.io/plugins/prometheus/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://prometheus.io/",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"http://localhost:9153/metrics",-1),I={href:"https://coredns.io/plugins/forward/",target:"_blank",rel:"noopener noreferrer"},q={href:"https://coredns.io/plugins/cache/",target:"_blank",rel:"noopener noreferrer"},A={href:"https://coredns.io/plugins/loop/",target:"_blank",rel:"noopener noreferrer"},L={href:"https://coredns.io/plugins/reload",target:"_blank",rel:"noopener noreferrer"},w={href:"https://coredns.io/plugins/loadbalance",target:"_blank",rel:"noopener noreferrer"},E=t(`<p>你可以通过修改 ConfigMap 来更改默认的 CoreDNS 行为。</p><blockquote><p>可选插件：</p><p>log：记录解析日志</p></blockquote><h3 id="coredns-服务端优化" tabindex="-1"><a class="header-anchor" href="#coredns-服务端优化" aria-hidden="true">#</a> CoreDNS 服务端优化</h3><p><strong>配置 Pod 打散</strong></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>
        <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>
          <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>
              <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>app
                <span class="token key atrule">operator</span><span class="token punctuation">:</span> In
                <span class="token key atrule">values</span><span class="token punctuation">:</span>
                <span class="token punctuation">-</span> kube<span class="token punctuation">-</span>dns
            <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>合理设置副本数</strong></p><p>1）80节点以下</p><p>副本数 = min ( max ( ceil (QPS/10000), ceil (集群节点数/8) ), 10 )</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 手动调整 CoreDNS 副本数</span>
kubectl scale <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token punctuation">{</span>target<span class="token punctuation">}</span> deployment/coredns <span class="token parameter variable">-n</span> kube-system <span class="token comment">#{target} 目标副本数量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>示例：</p><p>集群节点数为10，DNS 服务请求 QPS 为22000，则副本数为3。</p><p>集群节点数为30，DNS 服务请求 QPS 为15000，则副本数为4。</p></blockquote><p>2）80节点以上，安装 NodeLocal DNSCache</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 下载 YAML 文件</span>
<span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/kubernetes/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml
<span class="token comment"># 修改变量</span>
<span class="token assign-left variable">kubedns</span><span class="token operator">=</span><span class="token variable"><span class="token variable">\`</span>kubectl get svc kube-dns <span class="token parameter variable">-n</span> kube-system <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token punctuation">{</span>.spec.clusterIP<span class="token punctuation">}</span><span class="token variable">\`</span></span>
<span class="token assign-left variable">domain</span><span class="token operator">=</span><span class="token variable"><span class="token variable">\`</span><span class="token function">grep</span> clusterDomain <span class="token string">&#39;/var/lib/kubelet/config.yaml&#39;</span> <span class="token operator">|</span> <span class="token function">awk</span>  <span class="token string">&#39;{print $2}&#39;</span><span class="token variable">\`</span></span>
<span class="token assign-left variable">localdns</span><span class="token operator">=</span><span class="token string">&quot;169.254.20.10&quot;</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">&quot;s/__PILLAR__LOCAL__DNS__/<span class="token variable">$localdns</span>/g; s/__PILLAR__DNS__DOMAIN__/<span class="token variable">$domain</span>/g; s/,__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/<span class="token variable">$kubedns</span>/g&quot;</span> nodelocaldns.yaml
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">&#39;s#registry.k8s.io/dns/k8s-dns-node-cache:1.22.28#registry.cn-hangzhou.aliyuncs.com/clay-wangzhi/registry.k8s.io.dns.k8s-dns-node-cache:1.22.28#g&#39;</span> nodelocaldns.yaml
<span class="token comment"># 安装</span>
kubectl create <span class="token parameter variable">-f</span> nodelocaldns.yaml
<span class="token comment"># 修改 kubelet 重启</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;sed -i &quot;</span>s/<span class="token variable">$kubedns</span>/<span class="token variable">$localdns</span>/g<span class="token string">&quot; /var/lib/kubelet/config.yaml&quot;</span>
<span class="token comment"># 在每台 Node 节点，使用上面命令的输出结果替换 dns ip , 然后重启</span>
systemctl restart kubelet.service
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="客户端优化" tabindex="-1"><a class="header-anchor" href="#客户端优化" aria-hidden="true">#</a> 客户端优化</h3><p>在客户端，也可以做适当的优化配置，来提升 DNS 的使用体验。</p><ol><li><p><strong>修改 ndots 值</strong></p><p>默认情况下，Kubernetes 集群中的域名解析往往需要经过多次请求才能解析到。查看 pod 内 的 <code>/etc/resolv.conf</code> 可以知道 <code>ndots</code> 选项默认为 5。例如，在 debug 命名空间查询 <code>kubernetes.default.svc.cluster.local</code> 这个 service：</p><p>域名中有 4 个 <code>.</code> ，小于 5，尝试拼接上第一个 search 进行查询，即<code>kubernetes.default.svc.cluster.local.debug.svc.cluster.local</code> ，查不到该域名。</p><p>继续尝试 <code>kubernetes.default.svc.cluster.local.svc.cluster.local</code> ，查不到该域名。</p><p>继续尝试 <code>kubernetes.default.svc.cluster.local.cluster.local</code> ，仍然查不到该域名。</p><p>尝试不加后缀，即 <code>kubernetes.default.svc.cluster.local</code> ，查询成功，返回响应的 ClusterIP。</p><p>上面一个简单的 service 域名解析需要经过 4 轮解析才能成功，集群中充斥着大量无用的 DNS 请求。因此需要根据业务配置的访问方式来为其设置合理的 ndots 来降低查询次数：</p></li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">dnsConfig</span><span class="token punctuation">:</span>
    <span class="token key atrule">options</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ndots
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">&quot;2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>优化业务访问服务的域名配置</strong>：</p><p>Pod 访问本命名空间的 Service，使用 <code>&lt;service-name&gt;</code> 访问。</p><p>Pod 访问其它命名空间的 Service，使用 <code>&lt;service-name&gt;.&lt;namespace-name&gt;</code> 访问。</p><p>Pod 访问外部域名，使用 FQDN 类型域名访问，在域名最后添加 <code>.</code> 以减少无效搜索。</p></li><li><p><strong>修改 timeout、attempts</strong> glibc 的 resolver 库访问一个 name server 的超时时间默认为5秒，针对 /etc/resolv.conf 中列出的一组 name server，默认最多尝试（attempts）2次，如 /etc/resolv.conf 中配置两个 name server，当所有 name server 都不可用时，总超时时间为20秒，然而，这对于许多业务来说过于保守。可以根据业务实际需要，为 Pod 设置合理的 DNS 超时配置，以降低超时时间，避免 DNS 服务短时不可用导致业务吞吐量的显著下降，以下是一个示例：</p></li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">dnsConfig</span><span class="token punctuation">:</span>
    <span class="token key atrule">options</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> timeout
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">&quot;1&quot;</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> attempts
      <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">&quot;2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="coredns-监控" tabindex="-1"><a class="header-anchor" href="#coredns-监控" aria-hidden="true">#</a> CoreDNS 监控</h3><p>用自带的监控大盘即可，重点关注 Requests (total)、Responses (by rcode)、Responses (duration) 这几个指标即可，进行容量扩容，或结合日志进一步问题定位。</p><p>参考链接：</p><p>维基百科：https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</p><p>自定义 DNS 服务：https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/dns-custom-nameservers/</p><p>DNS概述：https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/dns-overview</p><p>TKE DNS 最佳实践：https://cloud.tencent.com/document/product/457/78005</p><p>在 Kubernetes 集群中使用 NodeLocal DNSCache：https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/nodelocaldns/</p><p>我是 Clay，下期见 👋</p><hr><blockquote><ul><li><p>欢迎订阅我的公众号「SRE运维进阶之路」或关注我的 Github https://github.com/clay-wangzhi/wiki 查看最新文章</p></li><li><p>欢迎加我微信<code>sre-k8s-ai</code>，与我讨论云原生、稳定性相关内容</p></li></ul></blockquote><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/weixin-20240220180036567.png" alt="weixin" style="zoom:50%;">`,30);function R(T,M){const s=l("ExternalLinkIcon");return r(),i("div",null,[p,n("p",null,[e("CoreDNS是Kubernetes集群中负责DNS解析的组件，能够支持解析集群内部自定义服务域名和集群外部域名。CoreDNS具备丰富的插件集，在集群层面支持自建DNS、自定义hosts、CNAME、rewrite等需求。与Kubernetes一样，CoreDNS项目由"),n("a",d,[e("CNCF"),a(s)]),e("托管。")]),u,n("p",null,[e("CoreDNS 是模块化且可插拔的 DNS 服务器，每个插件都为 CoreDNS 添加了新功能。 可以通过维护 "),n("a",k,[e("Corefile"),a(s)]),e("，即 CoreDNS 配置文件， 来配置 CoreDNS 服务器。作为一个集群管理员，你可以修改 CoreDNS Corefile 的 "),n("a",v,[e("ConfigMap"),a(s)]),e("， 以更改 DNS 服务发现针对该集群的工作方式。")]),m,n("p",null,[e("Corefile 配置包括以下 CoreDNS "),n("a",h,[e("插件"),a(s)]),e("：")]),n("ul",null,[n("li",null,[n("p",null,[n("a",b,[e("errors"),a(s)]),e("：错误记录到标准输出。")])]),n("li",null,[n("p",null,[n("a",g,[e("health"),a(s)]),e("：在 "),f,e(" 处提供 CoreDNS 的健康报告。 在这个扩展语法中，"),_,e(" 会使此进程不健康，等待 5 秒后进程被关闭。")])]),n("li",null,[n("p",null,[n("a",N,[e("ready"),a(s)]),e("：在端口 8181 上提供的一个 HTTP 端点， 当所有能够表达自身就绪的插件都已就绪时，在此端点返回 200 OK。")])]),n("li",null,[n("p",null,[n("a",y,[e("kubernetes"),a(s)]),e("：CoreDNS 将基于服务和 Pod 的 IP 来应答 DNS 查询。 你可以在 CoreDNS 网站找到有关此插件的"),n("a",S,[e("更多细节"),a(s)]),e("。")]),D]),n("li",null,[n("p",null,[n("a",C,[e("prometheus"),a(s)]),e("：CoreDNS 的度量指标值以 "),n("a",P,[e("Prometheus"),a(s)]),e(" 格式（也称为 OpenMetrics）在 "),x,e(" 上提供。")])]),n("li",null,[n("p",null,[n("a",I,[e("forward"),a(s)]),e(": 不在 Kubernetes 集群域内的任何查询都将转发到预定义的解析器 (/etc/resolv.conf)。")])]),n("li",null,[n("p",null,[n("a",q,[e("cache"),a(s)]),e("：启用前端缓存。")])]),n("li",null,[n("p",null,[n("a",A,[e("loop"),a(s)]),e("：检测简单的转发环，如果发现死循环，则中止 CoreDNS 进程。")])]),n("li",null,[n("p",null,[n("a",L,[e("reload"),a(s)]),e("：允许自动重新加载已更改的 Corefile。 编辑 ConfigMap 配置后，请等待两分钟，以使更改生效。")])]),n("li",null,[n("p",null,[n("a",w,[e("loadbalance"),a(s)]),e("：这是一个轮转式 DNS 负载均衡器， 它在应答中随机分配 A、AAAA 和 MX 记录的顺序。")])])]),E])}const K=o(c,[["render",R],["__file","coredns.html.vue"]]);export{K as default};
