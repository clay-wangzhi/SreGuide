import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,e as s}from"./app-f536079c.js";const i={},t=s(`<h1 id="_3-4-nginxlocation块配置" tabindex="-1"><a class="header-anchor" href="#_3-4-nginxlocation块配置" aria-hidden="true">#</a> 3.4 nginxLOCATION块配置</h1><p><code>nginx</code>中<code>location</code>的匹配模式有以下几种：</p><ul><li><p>精确匹配：以<code>=</code>开头，只有完全匹配才能生效，例子<code>location = /uri</code></p></li><li><p>非正则匹配：以<code>^~</code>开头，<code>^</code>表示非、<code>~</code>表示正则，例子<code>location ^~ /uri</code></p></li><li><p>正则匹配：</p><ul><li>以<code>~</code>开头，表示区分大小写的正则匹配，例子<code>location ~ pattern</code></li><li>以<code>!~</code>开头，表示区分大小写不匹配的正则，例子<code>location !~ pattern</code></li><li>以<code>~*</code>开头，表示不区分大小写的正则匹配，例子<code>location ~* pattern</code></li><li>以<code>!~*</code>开头，表示不区分大小写不匹配的正则，例子<code>location !~* pattern</code></li></ul></li><li><p>普通匹配：不带任何修饰符，例子<code>location /uri</code>、<code>location /</code></p></li></ul><blockquote><p>我们暂且把非正则匹配和普通匹配称为前缀匹配</p></blockquote><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/nginx中location匹配流程图.png" alt="nginx中location匹配流程图"></p><h2 id="_1-匹配模式优先级" tabindex="-1"><a class="header-anchor" href="#_1-匹配模式优先级" aria-hidden="true">#</a> 1 匹配模式优先级</h2><p><img src="https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20200320195331145.png" alt=""></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。
location ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。无正则普通匹配（^ 表示“非”，~ 表示“正则”，字符意思是：不要继续匹配正则）
location ~ pattern 　~开头表示区分大小写的正则匹配。!~为区分大小写不匹配的正则
location ~* pattern 　~*开头表示不区分大小写的正则匹配。!~*为不区分大小写不匹配的正则
location /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。
location / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意： 前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：location /dir1与location /dir1/dir2，如有请求http://localhost/dir1/dir2/file将最终匹配到location /dir1/dir2</p><p>优先级： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p><blockquote><p>上述的优先级不完全正确</p></blockquote><p>具体规则：</p><p>等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他location的匹配项</p><p>剩下的几种匹配优先级略复杂，具体可以查看Nginx官方文档（http://nginx.org/en/docs/http/ngx_http_core_module.html#location）</p><ul><li><p>^~和普通匹配。</p><p>使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会记忆表达式最长的那个。</p></li><li><p>如果上一步得到的最长的location为^~类型，则表示阻断正则表达式，不再匹配正则表达式</p></li><li><p>如果上一步得到的最长的location不是^~类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程</p></li></ul><p><strong>“最长”命中</strong></p><p>^~和普通命中，都是优先使用匹配最长的结果，示例如下：</p><p><strong>例子1</strong></p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /test_1</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">return</span> <span class="token number">400</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token directive"><span class="token keyword">location</span> ^~ /test</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">return</span> <span class="token number">401</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上如果path为/test_1，返回的是400，说明^~优先级并不比普通匹配高</p><p><strong>例子2</strong></p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /test_1</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">return</span> <span class="token number">400</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token directive"><span class="token keyword">location</span> ^~ /test</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">return</span> <span class="token number">401</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token directive"><span class="token keyword">location</span> ~ /test</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">return</span> <span class="token number">402</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上如果path为/test_1，返回的是402，此时^~和普通匹配只记住了最长一个location /test_1，不会阻止正则</p><p>如果path为/test，返回401，此时^~和普通匹配只记住了最长一个location ^~ /test，会阻止正则</p><h2 id="_2-路径替换" tabindex="-1"><a class="header-anchor" href="#_2-路径替换" aria-hidden="true">#</a> 2 路径替换</h2><p><strong>规则</strong></p><p>配置proxy_pass时，可以实现URL路径的部分替换。</p><p>proxy_pass的目标地址，默认不带/，表示只代理域名，url和querystring部分不会变（把请求的path拼接到proxy_pass目标域名之后作为代理的URL）。</p><p>如果在目标地址后增加/，则表示把path中location匹配成功的部分剪切掉之后再拼接到proxy_pass目标地址。</p><p>比如请求 /a/b.html</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /a</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://server</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /a/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://server/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上两个匹配成功后，实际代理的目标url分别是</p><p>http://server/a/b.html (把/a/b.html拼接到http://server之后)</p><p>http://server/b.html (把/a/b.html的/a/去掉之后，拼接到http://server/之后)</p><blockquote><p>通过 Nginx Server 访问 <code>http://nginx/nginx_location/some/path</code></p><p><code>proxy_pass</code>直接映射到主机的 <code>/test</code></p><p>建议location和proxy_pass后面都加上/，否则容易引起混乱。</p><table><thead><tr><th>location</th><th>proxy_pass</th><th>实际访问目标</th></tr></thead><tbody><tr><td><code>/nginx_location/</code></td><td><code>http://server/test/</code></td><td><code>http://server/test/some/path</code></td></tr></tbody></table></blockquote><p><strong>要求</strong></p><p>注意的是，对于location为正则表达式的匹配，proxy_pass的目标地址不可以带/</p><p>比如，如下配置会报错：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> ~ /abc(.*)</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span>   http://127.0.0.1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是正则表达式，想要实现proxy_pass的路径替换，可以使用如下方式：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> ~ /abc(.*)</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span>   http://127.0.0.1/<span class="token variable">$1</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-root和alias的使用" tabindex="-1"><a class="header-anchor" href="#_3-root和alias的使用" aria-hidden="true">#</a> 3 root和alias的使用</h2><p>nginx指定文件路径有两种方式root和alias，</p><p>root与alias主要区别在于nginx如何解释location后面的uri，</p><p>这会使两者分别以不同的方式将请求映射到服务器文件上。</p><h3 id="_3-1-最基本的区别" tabindex="-1"><a class="header-anchor" href="#_3-1-最基本的区别" aria-hidden="true">#</a> 3.1 最基本的区别</h3><p>alias 指定的目录是准确的，给location指定一个目录。</p><p>root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录。</p><p>以root方式设置资源路径：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法: root path;
配置块: http、server、location、if
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以alias 方式设置资源路径</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法: alias path;
配置块: location
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Example:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location /img/ {
	alias /var/www/image/;
}
#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件
location /img/ {
	root /var/www/image;
}
#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1.使用alias时，目录名后面一定要加”/“。
2.使用alias标签的目录块中不能使用rewrite的break。
3.alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。
4.alias只能位于location块中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以使用nginx设置root时要注意一个问题，就是如果该root设置的前端目录不是根目录，那么在写root的绝对地址时，要把前端目录的部分省略掉。 我们用设置虚拟目录指向的alias来和root比较一下就非常明显了</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location /abc/ {   alias /home/html/abc/; }  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这段配置下，http://test/abc/a.html就指定的是 /home/html/abc/a.html。这段配置亦可改成</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location /abc/ {   root /home/html/;} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，使用root设置目录的绝对路径时，少了/abc,也就是说，使用root来设置前端非根目录时，nginx会组合root和location的路径,即 /home/html/abc/。</p><h2 id="_4-try-files指令" tabindex="-1"><a class="header-anchor" href="#_4-try-files指令" aria-hidden="true">#</a> 4 try_files指令</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Syntax:	try_files file ... uri;
try_files file ... =code;
Default:	—
Context:	server, location
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong></p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /test/</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>功能：依次试图访问多个url对应的文件（由root或者alias指令指定），当文件存在是直接返回文件内容，如果所有文件都不存在，则按最后一个URL结果或者code返回</p><h2 id="_5-stub-status" tabindex="-1"><a class="header-anchor" href="#_5-stub-status" aria-hidden="true">#</a> 5 stub_status</h2><p>配置示例</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /basic_status</span> <span class="token punctuation">{</span>
	<span class="token directive"><span class="token keyword">stub_status</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ngx_http_stub_status_module模块內建的状态页 用于输出nginx的基本状态信息；</p><div class="language-undefined line-numbers-mode" data-ext="undefined"><pre class="language-undefined"><code>server{
....
	location /ngxstatus {
		stub_status;
	}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>信息页返回数值：</p><div class="language-undefined line-numbers-mode" data-ext="undefined"><pre class="language-undefined"><code>Active connections: 291
server accepts handled requests
16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Active connections: 活动状态的连接数；</li><li>accepts：已经接受的客户端请求的总数；</li><li>handled：已经处理完成的客户端请求的总数；</li><li>requests：客户端发来的总的请求数；</li><li>Reading：处于读取客户端请求报文首部的连接的连接数；</li><li>Writing：处于向客户端发送响应报文过程中的连接数；</li><li>Waiting：处于等待客户端发出请求的空闲连接数；</li></ul>`,75),l=[t];function o(d,c){return a(),e("div",null,l)}const u=n(i,[["render",o],["__file","location.html.vue"]]);export{u as default};
