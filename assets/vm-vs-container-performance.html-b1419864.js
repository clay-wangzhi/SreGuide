import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as d,c as i,a as t,b as e,d as r,e as l}from"./app-de4b287a.js";const c={},o=l(`<h1 id="什么-相同型号物理机-容器性能不如虚拟机" tabindex="-1"><a class="header-anchor" href="#什么-相同型号物理机-容器性能不如虚拟机" aria-hidden="true">#</a> 什么？相同型号物理机 容器性能不如虚拟机？</h1><h2 id="事件经过" tabindex="-1"><a class="header-anchor" href="#事件经过" aria-hidden="true">#</a> 事件经过</h2><blockquote><p>该应用通过虚拟机和容器混合部署，上线前压测了虚拟机上的应用性能，理论上流量高峰能抗住。</p></blockquote><p>[xx:xx] 流量突增，接口大量超时</p><p>[xx:xx] <strong>限流</strong></p><p>[xx:xx] <strong>重启</strong>，虚拟机能重启成功，容器重启失败，容器流量摘除，暂时恢复</p><p>[xx:xx] <strong>扩容</strong>， 容器虚拟机均扩容</p><p>[xx:xx] 两台容器异常，流量摘除</p><p>[xx:xx] 一段时间后观察正常，<strong>解除限流</strong></p><p>[xx:xx] 流量比上一次还大，接口大量超时</p><p>[xx:xx] <strong>限流</strong></p><p>[xx:xx] <strong>扩容</strong>，扩容发布均有失败，但是虚拟机成功率高，容器 fullGC 时间长，请求堆积，异常</p><p>[xx:xx] 定位代码存在性能问题</p><p>[xx:xx] 修复代码 bug，解决问题</p><p>[xx:xx] 定位到容器性能与虚拟机有一定差距（TPS 差一倍，平均 RT 高）</p><p>[xx:xx] 解决容器性能问题</p><h2 id="根因分析" tabindex="-1"><a class="header-anchor" href="#根因分析" aria-hidden="true">#</a> 根因分析</h2><blockquote><p>代码有 Bug ， 启动都会 fullGC ，都有启动失败的概率，但是容器 fullGC 耗时长，请求会不断堆积， 而虚拟机过段时间可以自行恢复</p><p>这里主要定位，为什么容器 fullGC 时间长，以及容器 TPS 低，平均 RT 高的问题</p></blockquote><p>定位分析业务的性能问题，也是很多程序员都很头疼的问题。需要你具备很高的业务能力，包括对业务流程的熟悉度、对软件架构及软件内实现逻辑的理解程度，甚至是对OS和硬件原理都要有深入的理解。即使是掌握了这些信息，如果没有系统的定位分析方法的指导，那你依旧很难定位出性能问题。</p><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/image-20240220164332294.png" alt=""></p><p>如上图： 排除 业务层 和 软件架构 两层，相同代码，相同物理机型号，相同机房的情况下，现在需要识别 软硬件性能瓶颈。</p><p>ok，热烈欢迎 性能领域的大师布伦丹·格雷格（Brendan Gregg）登场 👏👏👏</p><p><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/linux_perf_tools_full.png" alt="linux_perf_tools_full"></p><p>利用 随机变动讹方法（猜测，改动，观察验证） 查问题</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 先看 CPU,观察 CPU MHz、CPU max MHz、CPU min MHz，发现CPU MHz 处于 min 值</span>
lscpu
<span class="token comment"># 查看当前 CPU 性能模式</span>
<span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
<span class="token comment"># 调整设置为 performance 模式，进行验证</span>
cpupower frequency-set <span class="token parameter variable">-g</span> performance
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Nice，定位到了根因 ✌️</p><h2 id="后续-todo" tabindex="-1"><a class="header-anchor" href="#后续-todo" aria-hidden="true">#</a> 后续 TODO</h2><p>1）补全监控告警</p><p>将 node_exporter 升级到 1.6.0</p>`,29),p={href:"https://github.com/prometheus/node_exporter/pull/2569",target:"_blank",rel:"noopener noreferrer"},g=l(`<p>添加告警规则</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">name</span><span class="token punctuation">:</span> CPU 性能模式非 performance
<span class="token key atrule">expr</span><span class="token punctuation">:</span> (sum by(instance) (node_cpu_scaling_governor<span class="token punctuation">{</span>governor<span class="token tag">!=</span>&quot;performance&quot;<span class="token punctuation">}</span>) <span class="token punctuation">&gt;</span> 0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2）将虚拟机和容器， 进行 基础性能压测和服务性能压测，形成对比压测报告</p><blockquote><p>调整 CPU 性能模式后， 容器的整体性能 好于 虚拟机，主要体现在 磁盘性能方面，容器更优</p><p>规格均为：4c8g， 相同型号物理机</p></blockquote><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"></th><th style="text-align:left;">虚拟机</th><th style="text-align:left;">容器</th><th style="text-align:left;"></th></tr></thead><tbody><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>基础性能</strong></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">计算性能</td><td style="text-align:left;">Super_Pi</td><td style="text-align:left;">21.244秒</td><td style="text-align:left;">20.915秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">CPU调度延时 单线程</td><td style="text-align:left;">56.7微秒</td><td style="text-align:left;">16.7微秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">CPU调度延时 2线程</td><td style="text-align:left;">58.7微秒</td><td style="text-align:left;">19.3微秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">CPU调度延时 4线程</td><td style="text-align:left;">66.3微秒</td><td style="text-align:left;">26.3微秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 素数计算 单线程</td><td style="text-align:left;">4.483秒</td><td style="text-align:left;">4.454秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 素数计算 2线程</td><td style="text-align:left;">2.244秒</td><td style="text-align:left;">2.227秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 素数计算 4线程</td><td style="text-align:left;">1.124秒</td><td style="text-align:left;">1.116秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;">内存性能</td><td style="text-align:left;">内存带宽(stream) 单线程</td><td style="text-align:left;">Copy：11.0GB/s</td><td style="text-align:left;">Copy：12.9GB/s</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">内存带宽(stream) 单线程</td><td style="text-align:left;">Scale：11.1GB/s</td><td style="text-align:left;">Scale：13.0GB/s</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">内存带宽(stream) 单线程</td><td style="text-align:left;">Add：12.5GB/s</td><td style="text-align:left;">Add：14.4GB/s</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">内存带宽(stream) 单线程</td><td style="text-align:left;">Triad：12.7GB/s</td><td style="text-align:left;">Triad：14.6GB/s</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">内存时延(mlc)</td><td style="text-align:left;">138.0纳秒</td><td style="text-align:left;">146.8纳秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 顺序写</td><td style="text-align:left;">4082.59MiB/sec</td><td style="text-align:left;">4657.52MiB/sec</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 顺序读</td><td style="text-align:left;">52616.00MiB/sec</td><td style="text-align:left;">74925.36MiB/sec</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 随机写</td><td style="text-align:left;">527.66MiB/sec</td><td style="text-align:left;">533.09MiB/sec</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 随机读</td><td style="text-align:left;">7485.14MiB/sec</td><td style="text-align:left;">8376.67MiB/sec</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;">文件I/O性能</td><td style="text-align:left;">sysbench 随机读 IOPS</td><td style="text-align:left;">2759.53</td><td style="text-align:left;">14136.79</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 随机写 IOPS</td><td style="text-align:left;">1839.72</td><td style="text-align:left;">9424.53</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 顺序写吞吐量</td><td style="text-align:left;">76.89 MiB/s</td><td style="text-align:left;">1726.56 MiB/s</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">sysbench 顺序读吞吐量</td><td style="text-align:left;">17560.41 MiB/s</td><td style="text-align:left;">12356.24 MiB/s</td><td style="text-align:left;">↓</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">dd 顺序写</td><td style="text-align:left;">125.3 MB/s</td><td style="text-align:left;">1262.9 MB/s</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;">网络性能</td><td style="text-align:left;">传输速率(pps)</td><td style="text-align:left;">60w/s</td><td style="text-align:left;">49w/s</td><td style="text-align:left;">↓</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">网络带宽</td><td style="text-align:left;">8.75Gbps</td><td style="text-align:left;">8.75Gbps</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">单向时延</td><td style="text-align:left;">104.274微妙</td><td style="text-align:left;">30.743微秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">ping 时延</td><td style="text-align:left;">0.143毫秒</td><td style="text-align:left;">0.102毫秒</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>应用性能</strong></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Nginx</td><td style="text-align:left;">短连接 QPS</td><td style="text-align:left;">2.92万</td><td style="text-align:left;">3.20万</td><td style="text-align:left;">~=</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">长连接 QPS</td><td style="text-align:left;">17.75万</td><td style="text-align:left;">14.13万</td><td style="text-align:left;">↓</td></tr><tr><td style="text-align:left;">MySQL</td><td style="text-align:left;">读</td><td style="text-align:left;">79.19万/300秒</td><td style="text-align:left;">651.29万/300秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">写</td><td style="text-align:left;">22.63万/300秒</td><td style="text-align:left;">186.08万/300秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;">Redis</td><td style="text-align:left;">Set</td><td style="text-align:left;">14.88万/秒</td><td style="text-align:left;">15.42万/秒</td><td style="text-align:left;">↑</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Get</td><td style="text-align:left;">15.22万/秒</td><td style="text-align:left;">14.74万/秒</td><td style="text-align:left;">↓</td></tr></tbody></table><h2 id="同类硬件问题总结" tabindex="-1"><a class="header-anchor" href="#同类硬件问题总结" aria-hidden="true">#</a> 同类硬件问题总结</h2><h3 id="cpu" tabindex="-1"><a class="header-anchor" href="#cpu" aria-hidden="true">#</a> CPU</h3><p><strong>CPU-动态节能技术</strong></p><p>cpufreq 是一个动态调整 CPU 频率的模块，可支持五种模式。为保证服务性能应选用 performance 模式，将 CPU 频率固定工作在其支持的最高运行频率上，从而获取最佳的性能，一般都是默认 powersave，可以通过 cpupower frequency-set 修改。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看当前 CPU 性能模式</span>
<span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
<span class="token comment"># 查看当前 CPU 使用频率</span>
<span class="token function">cat</span> /proc/cpuinfo <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">&quot;cpu mhz&quot;</span>
<span class="token comment"># 综合查看方式</span>
cpupower frequency-info
<span class="token comment"># 设置为 performance 模式</span>
cpupower frequency-set <span class="token parameter variable">-g</span> performance
<span class="token comment"># 注意：如果使用 cpupower frequency-set 设置后，重启物理机后，配置失败，可能是 tuned-adm 的原因</span>
<span class="token comment"># 所以建议使用 tuned-adm 设置 CPU 性能模式</span>
tuned-adm profile latency-performance
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="raid-卡" tabindex="-1"><a class="header-anchor" href="#raid-卡" aria-hidden="true">#</a> RAID 卡</h3><p>写入策略对顺序写入性能影响比较大</p><ul><li><code>Write Policy</code>（写入策略）： <ul><li><code>Write Through</code>（透写）：并不利用 Raid 卡的 Cache，直接与磁盘进行交互。</li><li><code>Write Back</code>（回写）：是先写 Raid 卡缓存，再传入磁盘。因为写入缓存，操作系统就认为成功了，所以测试会发现写入性能非常快。 推荐</li></ul></li><li><code>Read Policy</code> （读取策略）: <ul><li><code>Read-ahead</code> （预读，适合顺序读）</li><li><code>No-Read-Ahead</code>（Normal非预读，一般在 Windows 服务器下推荐）</li></ul></li></ul><p>开启预读对顺序读影响很大测试会差20%-40%性能。</p><blockquote><p><strong>Tips</strong> 在《MySQL 技术内幕-InnoDB存储引擎》 第二版第9章，性能调优部分。有关于 <code>Write Policy</code> 的介绍，根据作者实测 MySQL，<code>Write Back</code> 比 <code>Write Through</code> 快将近 40 倍差距。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看 RAID 卡当前读写策略，去带外管理台看会方便一些</span>
<span class="token comment"># 去官网 Broadcom 下载 rpm 包，到服务器上去安装</span>
<span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> storcli-007.2508.0000.0000-1.noarch.rpm
<span class="token comment"># 写入策略改为 WB</span>
<span class="token comment">## v0 是查询结果，不同型号 name 不同</span>
<span class="token builtin class-name">cd</span> /opt/MegaRAID/storcli/ <span class="token operator">&amp;&amp;</span>  ./storcli64 /c0 /v0 <span class="token builtin class-name">set</span> <span class="token assign-left variable">wrcache</span><span class="token operator">=</span>WB
<span class="token comment"># 读取策略改为 RA</span>
<span class="token builtin class-name">cd</span> /opt/MegaRAID/storcli/ <span class="token operator">&amp;&amp;</span>  ./storcli64 /c0 /v0 <span class="token builtin class-name">set</span> <span class="token assign-left variable">rdcache</span><span class="token operator">=</span>ra
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="经验教训" tabindex="-1"><a class="header-anchor" href="#经验教训" aria-hidden="true">#</a> 经验教训</h2><p><strong>上线前，基准测试的重要性 &amp; 基准测试要包含应用的，以应用感知为准。</strong></p><p>下篇会详细 服务器性能压测指标及方法。</p><p>参考链接：性能优化高手课 | 尉刚强</p><p>我是 Clay，下期见 👋</p><hr><blockquote><ul><li><p>欢迎订阅我的公众号「SRE运维进阶之路」或关注我的 Github https://github.com/clay-wangzhi/wiki 查看最新文章</p></li><li><p>欢迎加我微信<code>sre-k8s-ai</code>，与我讨论云原生、稳定性相关内容</p></li></ul></blockquote><img src="https://clay-blog.oss-cn-shanghai.aliyuncs.com/img/weixin-20240220180036567.png" alt="weixin" style="zoom:33%;">`,24);function x(f,y){const s=a("ExternalLinkIcon");return d(),i("div",null,[o,t("ul",null,[t("li",null,[e("[ENHANCEMENT] Add cpu frequency governor metrics "),t("a",p,[e("#2569"),r(s)])])]),g])}const h=n(c,[["render",x],["__file","vm-vs-container-performance.html.vue"]]);export{h as default};
